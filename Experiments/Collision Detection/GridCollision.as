package {	import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.display.StageDisplayState;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.utils.getTimer;		[SWF (backgroundColor = 0xffffff, width = 1090, height = 800)]		public class GridCollision extends Sprite {		private const RADIUS:Number = 20;		private var mcWidth:Number = stage.stageWidth;		private var mcHeight:Number = stage.stageHeight;		private var gridSize = 50;		private var _ball:Ball;		private var _numBalls:int = 150;		private var _balls:Vector.<DisplayObject>;		private var _grid:VectorGridCollision;		private var displayIcon:MovieClip = new FullScreenIcon();		private var fpsTxt:TextField;		private var endTime:Number;				public function GridCollision():void {			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.SHOW_ALL;			_grid = new VectorGridCollision(mcWidth, mcHeight, gridSize);			_grid.drawGrids(graphics);			createBalls();						fpsTxt = new TextField();			fpsTxt.x = 20;			fpsTxt.y = 20;			fpsTxt.borderColor = 0x00000;			fpsTxt.border = true;			fpsTxt.autoSize = TextFieldAutoSize.CENTER;			fpsTxt.type = TextFieldType.DYNAMIC;			addChild(fpsTxt);						displayIcon.x = mcWidth - 100;			displayIcon.y = mcHeight - 100;			displayIcon.buttonMode = true;			addChild(displayIcon);			addEventListener(Event.ENTER_FRAME, onStart);		}						private function onStart(evt:Event):void {			var startTime:Number = getTimer();			var fpsRate:Number = Math.round(1000/ (startTime - endTime));			fpsTxt.text = "FPS: " + fpsRate;			displayIcon.addEventListener(MouseEvent.CLICK, goFullScreen);			updateBalls();			_grid.check(_balls);			var numChecks:int = _grid.checks.length;			for(var j:int = 0; j < numChecks; j += 2)			{				checkBalls(_grid.checks[j] as Ball, _grid.checks[j + 1] as Ball);			}			endTime = getTimer();		}						private function createBalls():void {			_balls = new Vector.<DisplayObject>();			for (var i:int = 0; i< _numBalls; i++) {				_ball = new Ball(RADIUS);				_ball.x = Math.random() * mcWidth;				_ball.y = Math.random() * mcHeight;				_ball.vx = Math.random() * 5 - 2;				_ball.vy = Math.random() * 5 - 2;				addChild(_ball);				_balls.push(_ball);			}		}				private function checkBalls(ballA:Ball, ballB:Ball):void {			var dx:Number = ballB.x - ballA.x;			var dy:Number = ballB.y - ballA.y;			var dist:Number = Math.sqrt(dx*dx + dy*dy);			if (dist < ballB.radius + ballA.radius) {				ballA.color = 0xff0000;				ballB.color = 0xff0000;			}		}				private function updateBalls():void {			for (var i:int = 0; i< _numBalls; i++) {				var ball:Ball = _balls[i] as Ball;				ball.update();								if (ball.x - ball.radius < 0) {					ball.x = ball.radius;					ball.vx *= -1;				}								else if (ball.x + ball.radius > mcWidth) {					ball.x = mcWidth - ball.radius;					ball.vx *= -1;				}								if (ball.y - ball.radius < 0) {					ball.y = ball.radius;					ball.vy *= -1;				}								else if (ball.y + ball.radius > mcHeight) {					ball.y = mcHeight - ball.radius;					ball.vy *= -1;				}								ball.color = 0xffffff;			}		}						private function goFullScreen(evt:MouseEvent):void {			if (stage.displayState == StageDisplayState.NORMAL) {				stage.displayState = StageDisplayState.FULL_SCREEN;			} else {				stage.displayState = StageDisplayState.NORMAL;			}		}	}}